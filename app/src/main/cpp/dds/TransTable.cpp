/*
   DDS, a bridge double dummy solver.

   Copyright (C) 2006-2014 by Bo Haglund /
   2014-2016 by Bo Haglund & Soren Hein.

   See LICENSE and README.
*/

#include <stdexcept>

#include "dds.h"
#include "TransTable.h"

extern unsigned char cardRank[16];
extern char relRank[8192][15];

const char * players[DDS_HANDS] =
{
  "North", "East", "South", "West"
};



/*
   This combines a small-memory and a full-memory version that
   are implemented completely differently, but they share a common
   interface.

   Explanation of full memory version:

   There are some constants that only need to be calculated
   once. In fact they are the same for all instances of the
   object. In order to save time and memory, they share a
   single memory.

   Each 13-bit number, aggr, represents a possible set of cards
   remaining in a suit. For example, 0x15a2 represents
   A(1) QT(5) 97(a) 3(2).

   TTlowestRank[aggr] gives the lowest relative rank that is in
   play in aggr. The ace is 14, the deuce is 2. A void counts as
   rank 15 ("not even the ace"). It would go horribly wrong
   if this rank were chosen to be 0, as might seem intuitive.
   This is not the same as lowestRank, the lowest absolute rank.

   maskBytes[aggr][suit] is a set of 4 32-bit integers,
   where suit is 0 ..3 (spades .. clubs). Each integer only
   has 8 of its 32 bits set, but these 8 bits could be either
   in the top byte (byte 0) or any of the others (bytes 1 ..3).
   The bytes are abbreviated as B0 .. B3 below.

                     int 0 int 1 int 2 int 3
   suit 0, spades B0 R0 B0 R1 B0 R2 B0 R3
   suit 1, hearts B1 R0 B1 R1 B1 R2 B1 R3
   suit 2, diamonds B2 R0 B2 R1 B2 R2 B2
   suit 3, clubs B3 R0 B3 R1 B3 R2 B3

   R0 .. R3 are explained now. The purpose of maskBytes is
   to generate 32-bit masks for later use with actual suits.
   As a card can be with either of 4 players, 2 bits are needed
   to encode the position of a card. Therefore the masks also
   need 2 bits per card, even though the 2 bits are identical.

   In the table, R0 means the top byte (8 bits = 4 cards) of
   a holding.

   R0 AKQJ
   R1 T987
   R2 6543
   R3 2

   For example, if the ace is held by North, the king by South, the
   queen and jack by West, then the top byte for that SUIT would be

   00(North) 10(South) 11(West) 11(West)

   The MASK for that holding would be 11 11 11 11, as all four
   cards are in play.

   If the jack were missing, because it had already been played,
   then the suit would be 00 10 11 00 (a missing card is also
   encoded as 00), and the mask would be 11 11 11 00.

   Later on, when we have a specific set of spades .. clubs,
   we want to check whether those cards are already in the
   transposition table. As far as the necessary masks is
   concerned, this is generated by an OR (|) of the four
   32-bit integers in a column of the table above.

   So the first column yields four bytes which are already
   shifted in place, all corresponding to R0. The mask
   corresponds to the AKQJ of the four suits in order.

   It's not really AKQJ, but the four highest cards still in
   play in that suit. So missing cards are always at the end
   of the list.
*/

bool _constantsSet = false;
int TTlowestRank[8192];
#ifndef SMALL_MEMORY_OPTION
  unsigned maskBytes[8192][DDS_SUITS][TT_BYTES];
#endif


TransTable::TransTable()
{
  if (! _constantsSet)
  {
    _constantsSet = true;
    TransTable::SetConstants();
  }

#ifndef SMALL_MEMORY_OPTION
  poolp = nullptr;
  pagesDefault = NUM_PAGES_DEFAULT;
  pagesMaximum = NUM_PAGES_MAXIMUM;
  pagesCurrent = 0;

  memState = FROM_POOL;
  harvestTrick = FIRST_HARVEST_TRICK;
  harvestHand = 0;

  harvested.nextBlockNo = 0;

  timestamp = 0;

  pageStats.numResets = 0;
  pageStats.numCallocs = 0;
  pageStats.numFrees = 0;
  pageStats.numHarvests = 0;
  pageStats.lastCurrent = 0;
#endif

  TTInUse = 0;

  strcpy(fname, "");
  fp = stdout;
}


TransTable::~TransTable()
{
  TransTable::ReturnAllMemory();

  if (fp != stdout && fp != nullptr)
    fclose(fp);
}


void TransTable::SetConstants()
{
  unsigned int topBitRank = 1;
  TTlowestRank[0] = 15; // Void
#ifndef SMALL_MEMORY_OPTION
  unsigned winMask[8192];
  winMask[0] = 0;
#endif

  for (unsigned ind = 1; ind < 8192; ind++)
  {
    if (ind >= (topBitRank + topBitRank)) /* Next top bit */
      topBitRank <<= 1;

#ifndef SMALL_MEMORY_OPTION
    // winMask is a growing list of 11's. In the end it will
    // have 26 bits, so 13 groups of two bits. It always
    // consists of all 11's, then all 00's.

    winMask[ind] = (winMask[ind ^ topBitRank] >> 2) | (3 << 24);

    maskBytes[ind][0][0] = (winMask[ind] << 6) & 0xff000000;
    maskBytes[ind][0][1] = (winMask[ind] << 14) & 0xff000000;
    maskBytes[ind][0][2] = (winMask[ind] << 22) & 0xff000000;
    maskBytes[ind][0][3] = (winMask[ind] << 30) & 0xff000000;

    maskBytes[ind][1][0] = (winMask[ind] >> 2) & 0x00ff0000;
    maskBytes[ind][1][1] = (winMask[ind] << 6) & 0x00ff0000;
    maskBytes[ind][1][2] = (winMask[ind] << 14) & 0x00ff0000;
    maskBytes[ind][1][3] = (winMask[ind] << 22) & 0x00ff0000;

    maskBytes[ind][2][0] = (winMask[ind] >> 10) & 0x0000ff00;
    maskBytes[ind][2][1] = (winMask[ind] >> 2) & 0x0000ff00;
    maskBytes[ind][2][2] = (winMask[ind] << 6) & 0x0000ff00;
    maskBytes[ind][2][3] = (winMask[ind] << 14) & 0x0000ff00;

    maskBytes[ind][3][0] = (winMask[ind] >> 18) & 0x000000ff;
    maskBytes[ind][3][1] = (winMask[ind] >> 10) & 0x000000ff;
    maskBytes[ind][3][2] = (winMask[ind] >> 2) & 0x000000ff;
    maskBytes[ind][3][3] = (winMask[ind] << 6) & 0x000000ff;
#endif

    TTlowestRank[ind] = TTlowestRank[ind ^ topBitRank] - 1;
  }
}


#ifdef SMALL_MEMORY_OPTION
void TransTable::Init(int handLookup[][15])
{
  unsigned int topBitRank = 1;
  unsigned int topBitNo = 2;

  for (int s = 0; s < DDS_SUITS; s++)
  {
    aggp[0].aggrRanks[s] = 0;
    aggp[0].winMask[s] = 0;
  }

  for (unsigned int ind = 1; ind < 8192; ind++)
  {
    if (ind >= (topBitRank + topBitRank))
    {
      /* Next top bit */
      topBitRank <<= 1;
      topBitNo++;
    }
    aggp[ind] = aggp[ind ^ topBitRank];

    for (int s = 0; s < 4; s++)
    {
      aggp[ind].aggrRanks[s] =
        (aggp[ind].aggrRanks[s] >> 2) |
        (handLookup[s][topBitNo] << 24);

      aggp[ind].winMask[s] =
        (aggp[ind].winMask[s] >> 2) | (3 << 24);
    }
  }

  return;
}

#else
void TransTable::Init(int handLookup[][15])
{
  // This is very similar to SetConstants, except that it
  // happens with actual cards. It also makes sense to
  // keep a record of aggrRanks for each suit. These are
  // only used later for xorSet.

  unsigned int topBitRank = 1;
  unsigned int topBitNo = 2;
  aggrType * ap;

  for (int s = 0; s < DDS_SUITS; s++)
  {
    aggr[0].aggrRanks[s] = 0;
    aggr[0].aggrBytes[s][0] = 0;
    aggr[0].aggrBytes[s][1] = 0;
    aggr[0].aggrBytes[s][2] = 0;
    aggr[0].aggrBytes[s][3] = 0;
  }

  for (unsigned ind = 1; ind < 8192; ind++)
  {
    if (ind >= (topBitRank << 1))
    {
      /* Next top bit */
      topBitRank <<= 1;
      topBitNo++;
    }

    aggr[ind] = aggr[ind ^ topBitRank];
    ap = &aggr[ind];

    for (int s = 0; s < DDS_SUITS; s++)
    {
      ap->aggrRanks[s] = ap->aggrRanks[s] >> 2 |
                          static_cast<unsigned>(handLookup[s][topBitNo] << 24);
    }

    ap->aggrBytes[0][0] = (ap->aggrRanks[0] << 6) & 0xff000000;
    ap->aggrBytes[0][1] = (ap->aggrRanks[0] << 14) & 0xff000000;
    ap->aggrBytes[0][2] = (ap->aggrRanks[0] << 22) & 0xff000000;
    ap->aggrBytes[0][3] = (ap->aggrRanks[0] << 30) & 0xff000000;

    ap->aggrBytes[1][0] = (ap->aggrRanks[1] >> 2) & 0x00ff0000;
    ap->aggrBytes[1][1] = (ap->aggrRanks[1] << 6) & 0x00ff0000;
    ap->aggrBytes[1][2] = (ap->aggrRanks[1] << 14) & 0x00ff0000;
    ap->aggrBytes[1][3] = (ap->aggrRanks[1] << 22) & 0x00ff0000;

    ap->aggrBytes[2][0] = (ap->aggrRanks[2] >> 10) & 0x0000ff00;
    ap->aggrBytes[2][1] = (ap->aggrRanks[2] >> 2) & 0x0000ff00;
    ap->aggrBytes[2][2] = (ap->aggrRanks[2] << 6) & 0x0000ff00;
    ap->aggrBytes[2][3] = (ap->aggrRanks[2] << 14) & 0x0000ff00;

    ap->aggrBytes[3][0] = (ap->aggrRanks[3] >> 18) & 0x000000ff;
    ap->aggrBytes[3][1] = (ap->aggrRanks[3] >> 10) & 0x000000ff;
    ap->aggrBytes[3][2] = (ap->aggrRanks[3] >> 2) & 0x000000ff;
    ap->aggrBytes[3][3] = (ap->aggrRanks[3] << 6) & 0x000000ff;
  }
}
#endif


void TransTable::SetMemoryDefault(int megabytes)
{
#ifdef SMALL_MEMORY_OPTION
  UNUSED(megabytes);
#else
  double blockMem = BLOCKS_PER_PAGE * sizeof(winBlockType) /
                    static_cast<double>(1024.);

  pagesDefault = static_cast<int>((1024 * megabytes) / blockMem);
#endif
}


void TransTable::SetMemoryMaximum(int megabytes)
{
#ifdef SMALL_MEMORY_OPTION
  maxmem = static_cast<unsigned long long>(1000000 * megabytes);
#else
  double blockMem = BLOCKS_PER_PAGE * sizeof(winBlockType) /
                    static_cast<double>(1024.);

  pagesMaximum = static_cast<int>((1024 * megabytes) / blockMem);
#endif
}


/////////////////////////////////////////////////////////////
//                                                         //
// Small memory TT functions.                              //
//                                                         //
/////////////////////////////////////////////////////////////

#ifdef SMALL_MEMORY_OPTION
void TransTable::MakeTT()
{
  int i;

  if (!TTInUse)
  {
    TTInUse = 1;

    summem = (WINIT + 1) * sizeof(winCardType) +
             (NINIT + 1) * sizeof(nodeCardsType) +
             (LSIZE + 1) * 52 * sizeof(posSearchTypeSmall);
    wmem = static_cast<int>((WSIZE + 1) * sizeof(winCardType));
    nmem = static_cast<int>((NSIZE + 1) * sizeof(nodeCardsType));

    maxIndex = static_cast<int>(
      (maxmem - summem) / ((WSIZE + 1) * sizeof(winCardType)));

    pw = static_cast<winCardType **>(calloc(static_cast<unsigned int>(maxIndex + 1), sizeof(struct winCardType *)));
    if (pw == NULL)
      exit(1);


    pn = static_cast<struct nodeCardsType **>(calloc(static_cast<unsigned int>(maxIndex + 1), sizeof(struct nodeCardsType *)));
    if (pn == NULL)
      exit(1);


    for (int k = 1; k <= 13; k++)
      for (int h = 0; h < DDS_HANDS; h++)
      {
        pl[k][h] = static_cast
                   <posSearchTypeSmall **>(calloc(static_cast<unsigned int>(maxIndex + 1),
                                             sizeof(posSearchTypeSmall *)));
        if (pl[k][h] == NULL)
          exit(1);
      }


    for (i = 0; i <= maxIndex; i++)
    {
      if (pw[i])
        free(pw[i]);
      pw[i] = NULL;
    }

    for (i = 0; i <= maxIndex; i++)
    {
      if (pn[i])
        free(pn[i]);
      pn[i] = NULL;
    }

    for (int k = 1; k <= 13; k++)
    {
      for (int h = 0; h < DDS_HANDS; h++)
      {
        for (i = 0; i <= maxIndex; i++)
        {
          if (pl[k][h][i])
            free(pl[k][h][i]);
          pl[k][h][i] = NULL;
        }
      }
    }

    pw[0] = static_cast<struct winCardType *>(calloc(WINIT + 1, sizeof(struct winCardType)));
    if (pw[0] == NULL)
      exit(1);

    pn[0] = static_cast<struct nodeCardsType *>(calloc(NINIT + 1, sizeof(struct nodeCardsType)));
    if (pn[0] == NULL)
      exit(1);

    for (int k = 1; k <= 13; k++)
      for (int h = 0; h < DDS_HANDS; h++)
      {
        pl[k][h][0] = static_cast<struct posSearchTypeSmall *>(calloc((LSIZE + 1),
                      sizeof(struct posSearchTypeSmall)));
        if (pl[k][h][0] == NULL)
          exit(1);
      }

    aggp = static_cast<struct ttAggrType *>(calloc(8192, sizeof(struct ttAggrType)));
    if (aggp == NULL)
      exit(1);

    InitTT();

    for (int k = 1; k <= 13; k++)
      aggrLenSets[k] = 0;
#if defined(DDS_TT_STATS)
    fprintf(fp, "Report of generated PosSearch nodes per trick level.\n");
    fprintf(fp, "Trick level 13 is highest level with all 52 cards.\n");
    fprintf(fp, "---------------------------------------------------\n");
#endif
    statsResets.noOfResets = 0;
    for (int k = 0; k <= 5; k++)
      statsResets.aggrResets[k] = 0;
    resetText[0] = "Unknown reason";
    resetText[1] = "Too many nodes";
    resetText[2] = "New deal";
    resetText[3] = "New trump";
    resetText[4] = "Memory exhausted";
    resetText[5] = "Free thread memory";
  }

  return;
}


void TransTable::Wipe()
{
  int m;

  for (m = 1; m <= wcount; m++)
  {
    if (pw[m])
      free(pw[m]);
    pw[m] = NULL;
  }
  for (m = 1; m <= ncount; m++)
  {
    if (pn[m])
      free(pn[m]);
    pn[m] = NULL;
  }

  for (int k = 1; k <= 13; k++)
  {
    for (int h = 0; h < DDS_HANDS; h++)
    {
      for (m = 1; m <= lcount[k][h]; m++)
      {
        if (pl[k][h][m])
          free(pl[k][h][m]);
        pl[k][h][m] = NULL;
      }
    }
  }

  allocmem = summem;

  return;
}



void TransTable::InitTT()
{
  winSetSizeLimit = WINIT;
  nodeSetSizeLimit = NINIT;
  allocmem = (WINIT + 1) * sizeof(struct winCardType);
  allocmem += (NINIT + 1) * sizeof(struct nodeCardsType);
  allocmem += (LSIZE + 1) * 52 * sizeof(struct posSearchTypeSmall);
  winCards = pw[0];
  nodeCards = pn[0];
  wcount = 0;
  ncount = 0;

  nodeSetSize = 0;
  winSetSize = 0;

  clearTTflag = false;
  windex = -1;

  for (int k = 1; k <= 13; k++)
    for (int h = 0; h < DDS_HANDS; h++)
    {
      posSearch[k][h] = pl[k][h][0];
      lenSetInd[k][h] = 0;
      lcount[k][h] = 0;
    }
}


void TransTable::ResetMemory(int reason)
{
  Wipe();

  InitTT();

  for (int k = 1; k <= 13; k++)
  {
    for (int h = 0; h < DDS_HANDS; h++)
    {
      rootnp[k][h] = &(posSearch[k][h][0]);
      posSearch[k][h][0].suitLengths = 0;
      posSearch[k][h][0].posSearchPoint = NULL;
      posSearch[k][h][0].left = NULL;
      posSearch[k][h][0].right = NULL;

      lenSetInd[k][h] = 1;
    }
  }

#if defined(DDS_TT_STATS)
  statsResets.noOfResets++;
  statsResets.aggrResets[reason]++;
#else
  UNUSED(reason);
#endif

  return;
}

void TransTable::ReturnAllMemory()
{

  if (!TTInUse)
    return;
  TTInUse = 0;

#if defined(DDS_TT_STATS)
  PrintResetStats();
  PrintNodeStats();
#endif


  Wipe();

  if (pw[0])
    free(pw[0]);
  pw[0] = NULL;

  if (pn[0])
    free(pn[0]);
  pn[0] = NULL;

  for (int k = 1; k <= 13; k++)
  {
    for (int h = 0; h < DDS_HANDS; h++)
    {
      if (pl[k][h][0])
        free(pl[k][h][0]);
      pl[k][h][0] = NULL;
    }
  }

  if (pw)
    free(pw);
  pw = NULL;

  if (pn)
    free(pn);
  pn = NULL;

  if (aggp)
    free(aggp);
  aggp = NULL;

  return;
}
#endif



/////////////////////////////////////////////////////////////
//                                                         //
// Full memory TT functions.                               //
//                                                         //
/////////////////////////////////////////////////////////////

#ifndef SMALL_MEMORY_OPTION
void TransTable::MakeTT()
{
  if (! TTInUse)
  {
    TTInUse = 1;

    for (int t = 0; t < TT_TRICKS; t++)
    {
      for (int h = 0; h < DDS_HANDS; h++)
      {
        TTroot[t][h] = static_cast<distHashType *>
                       (malloc(256 * sizeof(distHashType)));

        if (TTroot[t][h] == nullptr)
          exit(1);
      }
    }
  }

  TransTable::InitTT();
}


void TransTable::InitTT()
{
  for (int c = 0; c < TT_TRICKS; c++)
  {
    for (int h = 0; h < DDS_HANDS; h++)
    {
      for (int i = 0; i < 256; i++)
      {
        TTroot[c][h][i].nextNo = 0;
        TTroot[c][h][i].nextWriteNo = 0;

      }
      lastBlockSeen[c][h] = nullptr;
    }
  }
}


void TransTable::ReleaseTT()
{
  if (! TTInUse)
    return;
  TTInUse = 0;

  for (int t = 0; t < TT_TRICKS; t++)
  {
    for (int h = 0; h < DDS_HANDS; h++)
    {
      if (TTroot[t][h] == nullptr)
        continue;

      free(TTroot[t][h]);
    }
  }
}


void TransTable::ResetMemory(int reason)
{
  UNUSED(reason);
  if (poolp == nullptr)
    return;

  pageStats.numResets++;
  pageStats.numCallocs += pagesCurrent - pageStats.lastCurrent;
  pageStats.lastCurrent = pagesCurrent;

  while (pagesCurrent > pagesDefault)
  {
    free(poolp->list);
    poolp = poolp->prev;

    free(poolp->next);
    poolp->next = nullptr;

    pagesCurrent--;
  }

  pageStats.numFrees += pageStats.lastCurrent - pagesCurrent;
  pageStats.lastCurrent = pagesCurrent;

  while (poolp->prev)
    poolp = poolp->prev;

  poolp->nextBlockNo = 0;
  nextBlockp = poolp->list;

  TransTable::InitTT();

  timestamp = 0;

  memState = FROM_POOL;

  return;
}


void TransTable::ReturnAllMemory()
{
  poolType * tmp;

  if (poolp)
  {
    while (poolp->next)
      poolp = poolp->next;

    while (poolp)
    {
      free(poolp->list);
      tmp = poolp;
      poolp = poolp->prev;
      free(tmp);
    }
  }

  pagesCurrent = 0;

  pageStats.numResets = 0;
  pageStats.numCallocs = 0;
  pageStats.numFrees = 0;
  pageStats.numHarvests = 0;
  pageStats.lastCurrent = 0;

  TransTable::ReleaseTT();

  return;
}
#endif


int TransTable::BlocksInUse()
{
#ifndef SMALL_MEMORY_OPTION
  poolType * pp = poolp;
  int count = 0;

  do
  {
    count += pp->nextBlockNo;
    pp = pp->prev;
  }
  while (pp);

  return count;
#else
  return 0;
#endif
}


double TransTable::MemoryInUse()
{
#ifdef SMALL_MEMORY_OPTION
  int ttMem = static_cast<int>(allocmem);
  int aggrMem = 8192 * static_cast<int>(sizeof(ttAggrType));
  return (ttMem + aggrMem) / static_cast<double>(1024.);
#else
  int blockMem = BLOCKS_PER_PAGE * pagesCurrent *
                 static_cast<int>(sizeof(winBlockType));
  int aggrMem = 8192 * static_cast<int>(sizeof(aggrType));
  int rootMem = TT_TRICKS * DDS_HANDS * 256 *
                 static_cast<int>(sizeof(distHashType));

  return (blockMem + aggrMem + rootMem) / static_cast<double>(1024.);
#endif

}


TransTable::winBlockType * TransTable::GetNextCardBlock()
{
  /*
     Spaghetti code. The basic idea is that there is a pool of
     pages. When a page runs out, we get a next pool. But we're
     only allowed a certain maximum number, and calloc might also
     fail before then. We have a default number of pages that
     we don't give back voluntarily once we have acquired them,
     but we give back anything more than that at the end of each
     hand. If this overall mechanism fails, then we try to harvest
     old entries scattered throughout the TT memory. If we get
     enough for a "page", then we use that single page, and if
     that runs out later, we try to harvest some more, starting
     where we left off harvesting last time. If the harvesting also
     fails, then we reset whatever TT memory we do have, and we
     continue with that.
  */

#ifdef SMALL_MEMORY_OPTION
  return NULL;
#else
  if (poolp == nullptr)
  {
    // Have to be able to get at least one pool.
    poolp = static_cast<poolType *>(calloc(1, sizeof(poolType)));
    if (poolp == nullptr)
      exit(1);

    poolp->list = static_cast<winBlockType *>
                  (malloc(BLOCKS_PER_PAGE * sizeof(winBlockType)));

    if (! poolp->list)
      exit(1);

    poolp->next = nullptr;
    poolp->prev = nullptr;
    poolp->nextBlockNo = 1;

    nextBlockp = poolp->list;

    pagesCurrent++;

    return nextBlockp++;
  }
  else if (memState == FROM_HARVEST)
  {
    // Not allowed to get more memory, so reuse old one.
    int n = harvested.nextBlockNo;
    if (n == BLOCKS_PER_PAGE)
    {
      if (! TransTable::Harvest())
      {
        TransTable::ResetMemory(UNKNOWN_REASON);
        poolp->nextBlockNo++;
        return nextBlockp++;
      }
      n = 0;
    }

    harvested.nextBlockNo++;
    return harvested.list[n];
  }
  else if (poolp->nextBlockNo == BLOCKS_PER_PAGE)
  {
    if (poolp->next)
    {
      // Reuse a dormant block that has not been freed.
      poolp = poolp->next;
      poolp->nextBlockNo = 1;
      nextBlockp = poolp->list;

      return nextBlockp++;
    }
    else if (pagesCurrent == pagesMaximum)
    {
      // Have to try to reclaim memory.
      if (! TransTable::Harvest())
      {
        TransTable::ResetMemory(UNKNOWN_REASON);
        poolp->nextBlockNo++;
        return nextBlockp++;
      }

      memState = FROM_HARVEST;
      harvested.nextBlockNo++;
      return harvested.list[0];
    }
    else
    {
      // Make a new pool.
      poolType * newpoolp = static_cast<poolType *>
                            (calloc(1, sizeof(poolType)));

      if (newpoolp == nullptr)
      {
        // Unexpected, but try harvesting before we give up
        // and start over.
        if (! TransTable::Harvest())
        {
          TransTable::ResetMemory(UNKNOWN_REASON);
          poolp->nextBlockNo++;
          return nextBlockp++;
        }

        memState = FROM_HARVEST;
        harvested.nextBlockNo++;
        return harvested.list[0];
      }

      newpoolp->list = static_cast<winBlockType *>
                       (malloc(BLOCKS_PER_PAGE * sizeof(winBlockType)));

      if (! newpoolp->list)
      {
        if (! TransTable::Harvest())
        {
          TransTable::ResetMemory(UNKNOWN_REASON);
          poolp->nextBlockNo++;
          return nextBlockp++;
        }

        memState = FROM_HARVEST;
        harvested.nextBlockNo++;
        return harvested.list[0];
      }

      newpoolp->nextBlockNo = 1;
      newpoolp->next = nullptr;
      newpoolp->prev = poolp;

      poolp->next = newpoolp;
      poolp = newpoolp;

      nextBlockp = newpoolp->list;

      pagesCurrent++;

      return nextBlockp++;
    }
  }

  poolp->nextBlockNo++;
  return nextBlockp++;
#endif
}


bool TransTable::Harvest()
{
#ifdef SMALL_MEMORY_OPTION
  return false;
#else
  distHashType * rootptr = TTroot[harvestTrick][harvestHand];
  distHashType * ptr;
  winBlockType * bp;

  int trick = harvestTrick;
  int hand = harvestHand;
  int hash, suit, hno = 0;

  while (1)
  {
    for (hash = 0; hash < 256; hash++)
    {
      ptr = &rootptr[hash];
      for (suit = ptr->nextNo - 1; suit >= 0; suit--)
      {
        bp = ptr->list[suit].posBlock;
        if (timestamp - bp->timestampRead > HARVEST_AGE)
        {
          bp->nextMatchNo = 0;
          bp->nextWriteNo = 0;
          bp->timestampRead = timestamp;
          harvested.list[hno] = bp;

          // Swap the last element down.
          if (suit != ptr->nextNo - 1)
            ptr->list[suit] = ptr->list[ ptr->nextNo - 1 ];

          ptr->nextNo--;
          ptr->nextWriteNo = ptr->nextNo;

          if (++hno == BLOCKS_PER_PAGE)
          {
            if (++harvestHand >= DDS_HANDS)
            {
              // Skip rest of this [trick][hand] for simplicity.
              harvestHand = 0;
              if (--harvestTrick < 0)
                harvestTrick = FIRST_HARVEST_TRICK;
            }

            harvested.nextBlockNo = 0;
            pageStats.numHarvests++;
            return true;
          }
        }
      }
    }

    if (++harvestHand >= DDS_HANDS)
    {
      harvestHand = 0;
      if (--harvestTrick < 0)
        harvestTrick = FIRST_HARVEST_TRICK;
    }

    if (harvestTrick == trick && harvestHand == hand)
      return false;

    rootptr = TTroot[harvestTrick][harvestHand];
  }
#endif
}


int TransTable::hash8(int * handDist)
{
  /*
     handDist is an array of hand distributions, North .. West.
     Each entry is a 12-bit number with 3 groups of 4 bits.
     Each group is the binary representation of the number of
     cards held in that suit. The suits are in order spades,
     hearts, diamonds. Clubs can be neglected, as the total
     number of cards in a hand is given by the trick number.

     For example, if handDist[1] equals 0x0433, then East holds
     4 spades, 3 hearts, 3 diamonds and the rest in clubs.
     If this is after the second trick, there are 11 cards, so
     East must hold 1 club.

     The hash function turns all 4 hand distributions into a
     single 8-bit number. The numbers should be spread as
     evenly as possible across the 256 possibilities. I've not
     done extensive research into finding the best hash function,
     but this one seems OK. It uses a small prime, 5, and its
     powers. The shift at the end is in order to get some use
     out of the bits above the first 8 ones.
  */

  int h =
    (handDist[0] ^
     ((handDist[1] * 5) ) ^
     ((handDist[2] * 25) ) ^
     ((handDist[3] * 125) ) );

  return (h ^ (h >> 5)) & 0xff;
}


/////////////////////////////////////////////////////////////
//                                                         //
// Small memory TT functions.                              //
//                                                         //
/////////////////////////////////////////////////////////////


#ifdef SMALL_MEMORY_OPTION
nodeCardsType * TransTable::Lookup(
  int trick,
  int hand,
  unsigned short * aggrTarget,
  int * handDist,
  int limit,
  bool * lowerFlag)
{
  bool res;
  struct posSearchTypeSmall * pp;
  int orderSet[DDS_SUITS];
  struct nodeCardsType * cardsP;

  suitLengths[trick] =
    (static_cast<long long>(handDist[0]) << 36) |
    (static_cast<long long>(handDist[1]) << 24) |
    (static_cast<long long>(handDist[2]) << 12) |
    (static_cast<long long>(handDist[3]));

  pp = SearchLenAndInsert(rootnp[trick][hand],
                          suitLengths[trick], false, trick, hand, &res);

  /* Find node that fits the suit lengths */
  if ((pp != NULL) && res)
  {
    for (int ss = 0; ss < DDS_SUITS; ss++)
    {
      orderSet[ss] =
        aggp[aggrTarget[ss]].aggrRanks[ss];
    }

    if (pp->posSearchPoint == NULL)
      cardsP = NULL;
    else
    {
      cardsP = FindSOP(orderSet, limit, pp->posSearchPoint,
                       hand, lowerFlag);

      if (cardsP == NULL)
        return cardsP;
    }
  }
  else
  {
    cardsP = NULL;
  }
  return cardsP;
}


void TransTable::Add(
  int tricks,
  int hand,
  unsigned short * aggrTarget,
  unsigned short * ourWinRanks,
  nodeCardsType * first,
  bool flag)
{
  BuildSOP(ourWinRanks, aggrTarget, first, suitLengths[tricks],
           tricks, hand, tricks, flag);

  if (clearTTflag)
  {
    ResetMemory(MEMORY_EXHAUSTED);
  }

  return;
}
#endif


void TransTable::AddWinSet()
{
#ifdef SMALL_MEMORY_OPTION
  if (clearTTflag)
  {
    windex++;
    winSetSize = windex;
    winCards = &(temp_win[windex]);
  }
  else if (winSetSize >= winSetSizeLimit)
  {
    /* The memory chunk for the winCards structure will be exceeded. */
    if (((allocmem + static_cast<unsigned long long>(wmem)) > maxmem) || (wcount >= maxIndex) ||
        (winSetSize > SIMILARMAXWINNODES))
    {
      /* Already allocated memory plus needed allocation overshot maxmem */
      windex++;
      winSetSize = windex;
      clearTTflag = true;
      winCards = &(temp_win[windex]);
    }
    else
    {
      wcount++;
      winSetSizeLimit = WSIZE;
      pw[wcount] =
        static_cast<struct winCardType *>(calloc((WSIZE + 1), sizeof(struct winCardType)));
      if (pw[wcount] == NULL)
      {
        clearTTflag = true;
        windex++;
        winSetSize = windex;
        winCards = &(temp_win[windex]);
      }
      else
      {
        allocmem += (WSIZE + 1) * sizeof(struct winCardType);
        winSetSize = 0;
        winCards = pw[wcount];
      }
    }
  }
  else
    winSetSize++;
  return;
#endif
}

void TransTable::AddNodeSet()
{
#ifdef SMALL_MEMORY_OPTION
  if (nodeSetSize >= nodeSetSizeLimit)
  {
    /* The memory chunk for the nodeCards structure will be exceeded. */
    if (((allocmem + static_cast<unsigned long long>(nmem)) > maxmem) || (ncount >= maxIndex))
    {
      /* Already allocated memory plus needed allocation overshot maxmem */
      clearTTflag = true;
    }
    else
    {
      ncount++;
      nodeSetSizeLimit = NSIZE;
      pn[ncount] =
        static_cast<struct nodeCardsType *>(calloc((NSIZE + 1), sizeof(struct nodeCardsType)));
      if (pn[ncount] == NULL)
      {
        clearTTflag = true;
      }
      else
      {
        allocmem += (NSIZE + 1) * sizeof(struct nodeCardsType);
        nodeSetSize = 0;
        nodeCards = pn[ncount];
      }
    }
  }
  else
    nodeSetSize++;
  return;
#endif
}

void TransTable::AddLenSet(int trick, int firstHand)
{
#ifndef SMALL_MEMORY_OPTION
  UNUSED(trick);
  UNUSED(firstHand);
#else
  if (lenSetInd[trick][firstHand] >= LSIZE)
  {
    /* The memory chunk for the posSearchTypeSmall structure will be exceeded. */
    if (((allocmem + (LSIZE + 1) * sizeof(struct posSearchTypeSmall)) > maxmem)
        || (lcount[trick][firstHand] >= maxIndex))
    {
      /* Already allocated memory plus needed allocation overshot maxmem */
      clearTTflag = true;

      return;
    }

    /* Obtain another memory chunk LSIZE.*/

    lcount[trick][firstHand]++;

    pl[trick][firstHand][lcount[trick][firstHand]] =
      static_cast<struct posSearchTypeSmall *>(calloc(LSIZE + 1, sizeof(struct posSearchTypeSmall)));

    if (pl[trick][firstHand][lcount[trick][firstHand]] == NULL)

    {
      clearTTflag = true;

      return;
    }
    else
    {
      allocmem += (LSIZE + 1) * sizeof(struct posSearchTypeSmall);
      lenSetInd[trick][firstHand] = 0;
      posSearch[trick][firstHand] =
        pl[trick][firstHand][lcount[trick][firstHand]];

#if defined(DDS_TT_STATS)
      aggrLenSets[trick]++;
#endif
    }
  }
  else
  {
    lenSetInd[trick][firstHand]++;
#if defined(DDS_TT_STATS)
    aggrLenSets[trick]++;
#endif
  }
  return;
#endif
}


void TransTable::BuildSOP(
  unsigned short ourWinRanks[DDS_SUITS],
  unsigned short aggrArg[DDS_SUITS],
  struct nodeCardsType * first,
  long long lengths,
  int tricks,
  int firstHand,
  int depth,
  bool flag)
{
  UNUSED(depth);
#ifndef SMALL_MEMORY_OPTION
  UNUSED(ourWinRanks);
  UNUSED(aggrArg);
  UNUSED(first);
  UNUSED(lengths);
  UNUSED(tricks);
  UNUSED(firstHand);
  UNUSED(flag);
#else
  bool res;
  int w;
  unsigned short int temp;
  struct nodeCardsType * cardsP;
  struct posSearchTypeSmall * np;

  int winMask[DDS_SUITS];
  int winOrderSet[DDS_SUITS];
  char low[DDS_SUITS];

  for (int ss = 0; ss < DDS_SUITS; ss++)
  {
    w = ourWinRanks[ss];
    if (w == 0)
    {
      winMask[ss] = 0;
      winOrderSet[ss] = 0;
      low[ss] = 15;
    }
    else
    {
      w = w & (-w);       /* Only lowest win */
      temp = static_cast<unsigned short>(aggrArg[ss] & (-w));
      low[ss] = static_cast<char>(TTlowestRank[temp]);

      winMask[ss] = aggp[temp].winMask[ss];
      winOrderSet[ss] = aggp[temp].aggrRanks[ss];
    }
  }

  np = SearchLenAndInsert(rootnp[tricks][firstHand],
                          lengths, true, tricks, firstHand, &res);

  cardsP = BuildPath(winMask, winOrderSet,
                     static_cast<int>(first->ubound), static_cast<int>(first->lbound),
                     static_cast<char>(first->bestMoveSuit), static_cast<char>(first->bestMoveRank),
                     np, &res);


  if (res)
  {
    cardsP->ubound = static_cast<char>(first->ubound);
    cardsP->lbound = static_cast<char>(first->lbound);

    if (flag)
    {
      cardsP->bestMoveSuit = static_cast<char>(first->bestMoveSuit);
      cardsP->bestMoveRank = static_cast<char>(first->bestMoveRank);
    }
    else
    {
      cardsP->bestMoveSuit = 0;
      cardsP->bestMoveRank = 0;
    }

    for (int k = 0; k < DDS_SUITS; k++)
      cardsP->leastWin[k] = 15 - low[k];
  }
#endif
}


struct nodeCardsType * TransTable::BuildPath(
  int * winMask,
  int * winOrderSet,
  int ubound,
  int lbound,
  char bestMoveSuit,
  char bestMoveRank,
  struct posSearchTypeSmall * nodep,
  bool * result)
{
  /* If result is TRUE, a new SOP has been created and BuildPath returns a
  pointer to it. If result is FALSE, an existing SOP is used and BuildPath
  returns a pointer to the SOP */

#ifndef SMALL_MEMORY_OPTION
  UNUSED(winMask);
  UNUSED(winOrderSet);
  UNUSED(ubound);
  UNUSED(lbound);
  UNUSED(bestMoveSuit);
  UNUSED(bestMoveRank);
  UNUSED(nodep);
  UNUSED(result);
  return NULL;
#else
  bool found;
  struct winCardType * np, *p2, *nprev, *fnp, *pnp;
  struct winCardType temp;
  struct nodeCardsType * sopP = 0, *p;

  np = nodep->posSearchPoint;
  nprev = NULL;
  int suit = 0;

  /* If winning node has a card that equals the next winning card deduced
  from the position, then there already exists a (partial) path */

  if (np == NULL)
  {
    /* There is no winning list created yet */
    /* Create winning nodes */
    p2 = &(winCards[winSetSize]);
    AddWinSet();
    p2->next = NULL;
    p2->nextWin = NULL;
    p2->prevWin = NULL;
    nodep->posSearchPoint = p2;
    p2->winMask = winMask[suit];
    p2->orderSet = winOrderSet[suit];
    p2->first = NULL;
    np = p2;           /* Latest winning node */
    suit++;
    while (suit < 4)
    {
      p2 = &(winCards[winSetSize]);
      AddWinSet();
      np->nextWin = p2;
      p2->prevWin = np;
      p2->next = NULL;
      p2->nextWin = NULL;
      p2->winMask = winMask[suit];
      p2->orderSet = winOrderSet[suit];
      p2->first = NULL;
      np = p2;         /* Latest winning node */
      suit++;
    }
    p = &(nodeCards[nodeSetSize]);
    AddNodeSet();
    np->first = p;
    *result = true;
    return p;
  }
  else
  {
    /* Winning list exists */
    while (1)
    {
      /* Find all winning nodes that correspond to current
      position */
      found = false;
      while (1)      /* Find node amongst alternatives */
      {
        if ((np->winMask == winMask[suit]) &&
            (np->orderSet == winOrderSet[suit]))
        {
          /* Part of path found */
          found = true;
          nprev = np;
          break;
        }
        if (np->next != NULL)
          np = np->next;
        else
          break;
      }
      if (found)
      {
        suit++;
        if (suit > 3)
        {
          sopP = UpdateSOP(ubound, lbound, bestMoveSuit, bestMoveRank,
                           np->first);

          if (np->prevWin != NULL)
          {
            pnp = np->prevWin;
            fnp = pnp->nextWin;
          }
          else
            fnp = nodep->posSearchPoint;

          temp.orderSet = np->orderSet;
          temp.winMask = np->winMask;
          temp.first = np->first;
          temp.nextWin = np->nextWin;
          np->orderSet = fnp->orderSet;
          np->winMask = fnp->winMask;
          np->first = fnp->first;
          np->nextWin = fnp->nextWin;
          fnp->orderSet = temp.orderSet;
          fnp->winMask = temp.winMask;
          fnp->first = temp.first;
          fnp->nextWin = temp.nextWin;

          *result = false;
          return sopP;
        }
        else
        {
          np = np->nextWin;       /* Find next winning node  */
          continue;
        }
      }
      else
        break;                    /* Node was not found */
    }               /* End outer while */

    /* Create additional node, coupled to existing node(s) */
    p2 = &(winCards[winSetSize]);
    AddWinSet();
    p2->prevWin = nprev;
    if (nprev != NULL)
    {
      p2->next = nprev->nextWin;
      nprev->nextWin = p2;
    }
    else
    {
      p2->next = nodep->posSearchPoint;
      nodep->posSearchPoint = p2;
    }
    p2->nextWin = NULL;
    p2->winMask = winMask[suit];
    p2->orderSet = winOrderSet[suit];
    p2->first = NULL;
    np = p2;          /* Latest winning node */
    suit++;

    /* Rest of path must be created */
    while (suit < 4)
    {
      p2 = &(winCards[winSetSize]);
      AddWinSet();
      np->nextWin = p2;
      p2->prevWin = np;
      p2->next = NULL;
      p2->winMask = winMask[suit];
      p2->orderSet = winOrderSet[suit];
      p2->first = NULL;
      p2->nextWin = NULL;
      np = p2;         /* Latest winning node */
      suit++;
    }

    /* All winning nodes in SOP have been traversed and new nodes created */
    p = &(nodeCards[nodeSetSize]);
    AddNodeSet();
    np->first = p;
    *result = true;
    return p;
  }
#endif
}

struct TransTable::posSearchTypeSmall * TransTable::SearchLenAndInsert(
  struct posSearchTypeSmall * rootp,
  long long key,
  bool insertNode,
  int trick,
  int firstHand,
  bool * result)
{
  /* Search for node which matches with the suit length combination
  given by parameter key. If no such node is found, NULL is
  returned if parameter insertNode is FALSE, otherwise a new
  node is inserted with suitLengths set to key, the pointer to
  this node is returned.
  The algorithm used is defined in Knuth "The art of computer
  programming", vol.3 "Sorting and searching", 6.2.2 Algorithm T,
  page 424. */

#ifndef SMALL_MEMORY_OPTION
  UNUSED(rootp);
  UNUSED(key);
  UNUSED(insertNode);
  UNUSED(trick);
  UNUSED(firstHand);
  UNUSED(result);
  return NULL;
#else
  struct posSearchTypeSmall * np, *p, *sp;

  sp = NULL;
  if (insertNode)
    sp = &(posSearch[trick][firstHand][lenSetInd[trick][firstHand]]);

  np = rootp;
  while (1)
  {
    if (key == np->suitLengths)
    {
      *result = true;
      return np;
    }
    else if (key < np->suitLengths)
    {
      if (np->left != NULL)
        np = np->left;
      else if (insertNode)
      {
        p = sp;
        AddLenSet(trick, firstHand);
        np->left = p;
        p->posSearchPoint = NULL;
        p->suitLengths = key;
        p->left = NULL;
        p->right = NULL;
        *result = true;
        return p;
      }
      else
      {
        *result = false;
        return NULL;
      }
    }
    else        /* key > suitLengths */
    {
      if (np->right != NULL)
        np = np->right;
      else if (insertNode)
      {
        p = sp;
        AddLenSet(trick, firstHand);
        np->right = p;
        p->posSearchPoint = NULL;
        p->suitLengths = key;
        p->left = NULL;
        p->right = NULL;
        *result = true;
        return p;
      }
      else
      {
        *result = false;
        return NULL;
      }
    }
  }
#endif
}


struct nodeCardsType * TransTable::UpdateSOP(
  int ubound,
  int lbound,
  char bestMoveSuit,
  char bestMoveRank,
  nodeCardsType * nodep)
{
  /* Update SOP node with new values for upper and lower
  bounds. */
#ifndef SMALL_MEMORY_OPTION
  UNUSED(ubound);
  UNUSED(lbound);
  UNUSED(bestMoveSuit);
  UNUSED(bestMoveRank);
  UNUSED(nodep);
  return NULL;
#else
  if ((lbound > nodep->lbound) ||
      (nodep->lbound == -1))
    nodep->lbound = static_cast<char>(lbound);
  if ((ubound < nodep->ubound) ||
      (nodep->ubound == -1))
    nodep->ubound = static_cast<char>(ubound);

  nodep->bestMoveSuit = bestMoveSuit;
  nodep->bestMoveRank = bestMoveRank;

  return nodep;
#endif
}


struct nodeCardsType * TransTable::FindSOP(
  int orderSet[],
  int limit,
  winCardType * nodeP,
  int firstHand,
  bool	* lowerFlag)
{
  struct winCardType * np;
  UNUSED(firstHand);

  np = nodeP;
  int s = 0;

  while (np)
  {
    if ((np->winMask & orderSet[s]) == np->orderSet)
    {
      /* Winning rank set fits position */
      if (s != 3)
      {
        np = np->nextWin;
        s++;
        continue;
      }

      if (np->first->lbound > limit)
      {
        *lowerFlag = true;
        return np->first;
      }
      else if (np->first->ubound <= limit)
      {
        *lowerFlag = false;
        return np->first;
      }
    }

    while (np->next == NULL)
    {
      np = np->prevWin;
      s--;
      if (np == NULL) /* Previous node is header node? */
        return NULL;
    }
    np = np->next;
  }
  return NULL;
}



/////////////////////////////////////////////////////////////
//                                                         //
// Full memory TT functions.                               //
//                                                         //
/////////////////////////////////////////////////////////////

#ifndef SMALL_MEMORY_OPTION
nodeCardsType * TransTable::Lookup(
  int tricks,
  int hand,
  unsigned short aggrTarget[],
  int handDist[],
  int limit,
  bool * lowerFlag)
{
  // First look up distribution.
  long long suitLengths =
    (static_cast<long long>(handDist[0]) << 36) |
    (static_cast<long long>(handDist[1]) << 24) |
    (static_cast<long long>(handDist[2]) << 12) |
    (static_cast<long long>(handDist[3]) );

  int hashkey = hash8(handDist);

  bool empty;
  lastBlockSeen[tricks][hand] =
    LookupSuit(&TTroot[tricks][hand][hashkey],
               suitLengths, &empty);
  if (empty)
    return nullptr;

  // If that worked, look up cards.
  unsigned * ab0 = aggr[ aggrTarget[0] ].aggrBytes[0];
  unsigned * ab1 = aggr[ aggrTarget[1] ].aggrBytes[1];
  unsigned * ab2 = aggr[ aggrTarget[2] ].aggrBytes[2];
  unsigned * ab3 = aggr[ aggrTarget[3] ].aggrBytes[3];

  winMatchType TTentry;
  TTentry.topSet1 = ab0[0] | ab1[0] | ab2[0] | ab3[0];
  TTentry.topSet2 = ab0[1] | ab1[1] | ab2[1] | ab3[1];
  TTentry.topSet3 = ab0[2] | ab1[2] | ab2[2] | ab3[2];
  TTentry.topSet4 = ab0[3] | ab1[3] | ab2[3] | ab3[3];

  return TransTable::LookupCards(&TTentry,
    lastBlockSeen[tricks][hand], limit, lowerFlag);
}
#endif


TransTable::winBlockType * TransTable::LookupSuit(
  distHashType * dp,
  long long key,
  bool * empty)
{
  /*
     Always returns a valid winBlockType.
     If empty == true, there was no match, so there is
     no point in looking for a card match.
     If empty == false, there were entries already.
  */

  int n = dp->nextNo;
  for (int i = 0; i < n; i++)
  {
    if (dp->list[i].key == key)
    {
      *empty = false;
      return dp->list[i].posBlock;
    }
  }

  *empty = true;
  int m;

  if (n == DISTS_PER_ENTRY)
  {
    // No room for new exact suits at this hash position.
    // Have to reuse an existing posBlock.
    if (dp->nextWriteNo == DISTS_PER_ENTRY)
    {
      m = 0;
      dp->nextWriteNo = 1;
    }
    else
      m = dp->nextWriteNo++;
  }
  else
  {
    // Didn't find an exact match, but there is still room.
    // The following looks a bit odd because it is possible that
    // GetNextCardBlock wipes out the whole memory, so we
    // have to use the up-to-date location, not m from above.

    winBlockType * bp = GetNextCardBlock();
    m = dp->nextWriteNo++;
    dp->list[m].posBlock = bp;
    dp->list[m].posBlock->timestampRead = timestamp;
    dp->nextNo++;
  }

  // As long as the secondary Lookup loop in ABsearch exists,
  // it will cause spurious extra blocks to be created here
  // which are not useful, because nothing is ever Add'ed.
  // This is not a memory leak, as the memory is properly freed,
  // but it is also a small waste of about 0.5%. I don't mind.

  dp->list[m].key = key;
  dp->list[m].posBlock->nextMatchNo = 0;
  dp->list[m].posBlock->nextWriteNo = 0;

  return dp->list[m].posBlock;
}


nodeCardsType * TransTable::LookupCards(
  winMatchType * searchp,
  winBlockType * bp,
  int limit,
  bool * lowerFlag)
{
  winMatchType * wp;

  int n = bp->nextWriteNo - 1;
  wp = &bp->list[n];

  // It may be a bit silly to duplicate the code like this.
  // It could be combined to one loop with a slight overhead.

  for (int i = n; i >= 0; i--, wp--)
  {
    if ((wp->topSet1 ^ searchp->topSet1) & wp->topMask1)
      continue;

    if (wp->lastMaskNo != 1)
    {
      if ((wp->topSet2 ^ searchp->topSet2) & wp->topMask2)
        continue;

      if (wp->lastMaskNo != 2)
      {
        if ((wp->topSet3 ^ searchp->topSet3) & wp->topMask3)
          continue;
      }
    }

    // Check bounds.
    nodeCardsType * nodep = &wp->first;
    if (nodep->lbound > limit)
    {
      bp->timestampRead = ++timestamp;
      * lowerFlag = true;
      return nodep;
    }
    else if (nodep->ubound <= limit)
    {
      bp->timestampRead = ++timestamp;
      * lowerFlag = false;
      return nodep;
    }
  }

  int n2 = bp->nextMatchNo - 1;
  wp = &bp->list[n2];

  for (int i = n2; i > n; i--, wp--)
  {
    if ((wp->topSet1 ^ searchp->topSet1) & wp->topMask1)
      continue;

    if (wp->lastMaskNo != 1)
    {
      if ((wp->topSet2 ^ searchp->topSet2) & wp->topMask2)
        continue;

      if (wp->lastMaskNo != 2)
      {
        if ((wp->topSet3 ^ searchp->topSet3) & wp->topMask3)
          continue;
      }
    }

    nodeCardsType * nodep = &wp->first;
    if (nodep->lbound > limit)
    {
      * lowerFlag = true;
      bp->timestampRead = ++timestamp;
      return nodep;
    }
    else if (nodep->ubound <= limit)
    {
      * lowerFlag = false;
      bp->timestampRead = ++timestamp;
      return nodep;
    }
  }

  return nullptr;
}


void TransTable::CreateOrUpdate(
  winBlockType * bp,
  winMatchType * searchp,
  bool flag)
{
  // Either updates an existing SOP or creates a new one.
  // A new one is created at the end of the bp list if this
  // is not already full, or the oldest one in the list is
  // overwritten.

  winMatchType * wp = bp->list;
  int n = bp->nextMatchNo;

  for (int i = 0; i < n; i++, wp++)
  {
    if (wp->xorSet != searchp->xorSet ) continue;
    if (wp->maskIndex != searchp->maskIndex) continue;
    if (wp->topSet1 != searchp->topSet1 ) continue;
    if (wp->topSet2 != searchp->topSet2 ) continue;
    if (wp->topSet3 != searchp->topSet3 ) continue;

    nodeCardsType * nodep = &wp->first;
    if (searchp->first.lbound > nodep->lbound)
      nodep->lbound = searchp->first.lbound;
    if (searchp->first.ubound < nodep->ubound)
      nodep->ubound = searchp->first.ubound;

    nodep->bestMoveSuit = searchp->first.bestMoveSuit;
    nodep->bestMoveRank = searchp->first.bestMoveRank;
    return;
  }

  if (n == BLOCKS_PER_ENTRY)
  {
    if (bp->nextWriteNo >= BLOCKS_PER_ENTRY)
      bp->nextWriteNo = 0;
  }
  else
    bp->nextMatchNo++;


  wp = &bp->list[ bp->nextWriteNo++ ];
  *wp = *searchp;

  if (!flag)
  {
    wp->first.bestMoveSuit = 0;
    wp->first.bestMoveRank = 0;
  }
}


#ifndef SMALL_MEMORY_OPTION
void TransTable::Add(
  int tricks,
  int hand,
  unsigned short * aggrTarget,
  unsigned short * ourWinRanks,
  nodeCardsType * first,
  bool flag)
{
  if (lastBlockSeen[tricks][hand] == nullptr)
  {
    // We have recently reset the entire memory, and we were
    // in the middle of a recursion. So we'll just have to
    // drop this entry that we were supposed to be adding.
    return;
  }

  unsigned * ab[DDS_SUITS];
  unsigned * mb[DDS_SUITS];
  char low[DDS_SUITS];
  unsigned short int ag;
  int w;
  winMatchType TTentry;

  // Inefficient, as it also copies leastWin.
  // In fact I'm not quite happy with the treatment of
  // leastWin in general.

  TTentry.first = *first;

  TTentry.xorSet = 0;

  for (int ss = 0; ss < DDS_SUITS; ss++)
  {
    w = static_cast<int>(ourWinRanks[ss]);
    if (w == 0)
    {
      ab[ss] = aggr[0].aggrBytes[ss];
      mb[ss] = maskBytes[0][ss];
      low[ss] = 15;
      TTentry.first.leastWin[ss] = 0;
    }
    else
    {
      w = w & (-w); /* Only lowest win */
      ag = static_cast<unsigned short>(aggrTarget[ss] & (-w));

      ab[ss] = aggr[ag].aggrBytes[ss];
      mb[ss] = maskBytes[ag][ss];
      low[ss] = static_cast<char>(TTlowestRank[ag]);

      TTentry.first.leastWin[ss] = 15 - low[ss];
      TTentry.xorSet ^= aggr[ag].aggrRanks[ss];
    }
  }

  // It's a bit annoying that we may be regenerating these.
  // But winRanks can cause them to change after lookup().

  TTentry.topSet1 = ab[0][0] | ab[1][0] | ab[2][0] | ab[3][0];
  TTentry.topSet2 = ab[0][1] | ab[1][1] | ab[2][1] | ab[3][1];
  TTentry.topSet3 = ab[0][2] | ab[1][2] | ab[2][2] | ab[3][2];
  TTentry.topSet4 = ab[0][3] | ab[1][3] | ab[2][3] | ab[3][3];

  TTentry.topMask1 = mb[0][0] | mb[1][0] | mb[2][0] | mb[3][0];
  TTentry.topMask2 = mb[0][1] | mb[1][1] | mb[2][1] | mb[3][1];
  TTentry.topMask3 = mb[0][2] | mb[1][2] | mb[2][2] | mb[3][2];
  TTentry.topMask4 = mb[0][3] | mb[1][3] | mb[2][3] | mb[3][3];

  TTentry.maskIndex =
    (low[0] << 12) | (low[1] << 8) | (low[2] << 4) | low[3];

  if (TTentry.topMask2 == 0)
    TTentry.lastMaskNo = 1;
  else if (TTentry.topMask3 == 0)
    TTentry.lastMaskNo = 2;
  else if (TTentry.topMask4 == 0)
    TTentry.lastMaskNo = 3;
  else
    TTentry.lastMaskNo = 4;

  TransTable::CreateOrUpdate(lastBlockSeen[tricks][hand],
                             &TTentry, flag);
}
#endif



void TransTable::PrintMatch(
  winMatchType * wp,
  unsigned char lengths[DDS_HANDS][DDS_SUITS])
{
  char hands[DDS_HANDS][DDS_SUITS][TT_LINE_LEN];
  int used[DDS_HANDS][DDS_SUITS];

  for (int h = 0; h < DDS_HANDS; h++)
  {
    for (int s = 0; s < DDS_SUITS; s++)
    {
      used[h][s] = 0;
      for (int c = 0; c < TT_LINE_LEN; c++)
        hands[h][s][c] = 0;
    }
  }

  TransTable::SetToPartialHands(
    wp->topSet1, wp->topMask1, 14, 4, hands, used);
  TransTable::SetToPartialHands(
    wp->topSet2, wp->topMask2, 10, 4, hands, used);
  TransTable::SetToPartialHands(
    wp->topSet3, wp->topMask3, 6, 4, hands, used);
  TransTable::SetToPartialHands(
    wp->topSet4, wp->topMask4, 2, 1, hands, used);

  TransTable::DumpHands(hands, lengths);

  TransTable::PrintNodeValues(&wp->first);
}


void TransTable::PrintNodeValues(
  nodeCardsType * np)
{
  if (!np)
  {
    fprintf(fp, "np == nullptr\n");
    return;
  }

  fprintf(fp, "Lowest used\t%c%c, %c%c, %c%c, %c%c\n",
          cardSuit[0], cardRank[ 15 - static_cast<int>(np->leastWin[0]) ],
          cardSuit[1], cardRank[ 15 - static_cast<int>(np->leastWin[1]) ],
          cardSuit[2], cardRank[ 15 - static_cast<int>(np->leastWin[2]) ],
          cardSuit[3], cardRank[ 15 - static_cast<int>(np->leastWin[3]) ]);

  fprintf(fp, "Bounds\t\t%d to %2d tricks\n",
          static_cast<int>(np->lbound),
          static_cast<int>(np->ubound));

  fprintf(fp, "Best move\t%c%c\n",
          cardSuit[ static_cast<int>(np->bestMoveSuit) ],
          cardRank[ static_cast<int>(np->bestMoveRank) ]);

  fprintf(fp, "\n");
}


void TransTable::MakeHolding(
  char * high,
  unsigned len,
  char * res)
{
  unsigned l = strlen(high);
  strcpy(res, high);

  if (len == 0 && (l == 0 || (l == 1 && high[0] == '\0')))
  {
    res[0] = '-';
    res[1] = '\0';
    return;
  }

  for (unsigned i = l; i < len; i++)
  {
    res[i] = 'x';
  }
  res[len] = '\0';
}


void TransTable::DumpHands(
  char hands[DDS_HANDS][DDS_SUITS][TT_LINE_LEN],
  unsigned char lengths[DDS_HANDS][DDS_SUITS])
{
  char res_a[TT_LINE_LEN], res_b[TT_LINE_LEN];

  for (int i = 0; i < DDS_SUITS; i++)
  {
    TransTable::MakeHolding(hands[0][i],
                            static_cast<unsigned>(lengths[0][i]), res_a);
    fprintf(fp, "%16s%s\n", "", res_a);
  }

  for (int i = 0; i < DDS_SUITS; i++)
  {
    TransTable::MakeHolding(hands[3][i],
                            static_cast<unsigned>(lengths[3][i]), res_a);
    TransTable::MakeHolding(hands[1][i],
                            static_cast<unsigned>(lengths[1][i]), res_b);
    fprintf(fp, "%-16s%16s%-16s\n", res_a, "", res_b);
  }

  for (int i = 0; i < DDS_SUITS; i++)
  {
    char res[16];
    TransTable::MakeHolding(hands[2][i],
                            static_cast<unsigned>(lengths[2][i]), res);
    fprintf(fp, "%16s%s\n", "", res);
  }
  fprintf(fp, "\n");
}


void TransTable::SetToPartialHands(
  unsigned set,
  unsigned mask,
  int maxRank,
  int numRanks,
  char hands[DDS_HANDS][DDS_SUITS][TT_LINE_LEN],
  int used[DDS_HANDS][DDS_SUITS])
{
  for (int s = 0; s < DDS_SUITS; s++)
  {
    for (int rank = maxRank; rank > maxRank - numRanks; rank--)
    {
      int shift = 8 * (3 - s) + 2 * (rank - maxRank + 3);
      unsigned maskCard = mask >> shift;

      if (maskCard & 3)
      {
        unsigned player = (set >> shift) & 3;
        hands[player][s][ used[player][s]++ ] =
          static_cast<char>(cardRank[rank]);
      }
    }
  }
}


void TransTable::SetFile(char * ourFname)
{
  if (strlen(ourFname) > TT_LINE_LEN)
    return;

  if (fp != stdout) // Already set
    return;

  strncpy(fname, ourFname, strlen(ourFname));

  fp = fopen(fname, "w");
  if (! fp)
    fp = stdout;
}


void TransTable::KeyToDist(
  long long key,
  int handDist[])
{
  handDist[0] = static_cast<int>((key >> 36) & 0x00000fff);
  handDist[1] = static_cast<int>((key >> 24) & 0x00000fff);
  handDist[2] = static_cast<int>((key >> 12) & 0x00000fff);
  handDist[3] = static_cast<int>((key ) & 0x00000fff);
}


void TransTable::DistToLengths(
  int trick,
  int handDist[],
  unsigned char lengths[DDS_HANDS][DDS_SUITS])
{
  for (int h = 0; h < DDS_HANDS; h++)
  {
    lengths[h][0] = static_cast<unsigned char>((handDist[h] >> 8) & 0xf);
    lengths[h][1] = static_cast<unsigned char>((handDist[h] >> 4) & 0xf);
    lengths[h][2] = static_cast<unsigned char>((handDist[h] ) & 0xf);
    lengths[h][3] = static_cast<unsigned char>
                    (trick + 1
                     - lengths[h][0]
                     - lengths[h][1]
                     - lengths[h][2]);
  }
}


void TransTable::LenToStr(
  unsigned char len[DDS_HANDS][DDS_SUITS],
  char * line)
{
  sprintf(line,
          "%d=%d=%d=%d \t%d=%d=%d=%d \t%d=%d=%d=%d \t%d=%d=%d=%d",
          len[0][0], len[0][1], len[0][2], len[0][3],
          len[1][0], len[1][1], len[1][2], len[1][3],
          len[2][0], len[2][1], len[2][2], len[2][3],
          len[3][0], len[3][1], len[3][2], len[3][3]);
}


void TransTable::PrintSuits(
  int trick,
  int hand)
{
#ifdef SMALL_MEMORY_OPTION
  UNUSED(trick);
  UNUSED(hand);
#else
  distHashType * dp;
  int handDist[DDS_HANDS];
  unsigned char len[DDS_HANDS][DDS_SUITS];
  char line[40];

  fprintf(fp, "%4s %2s %-8s\t%-8s\t%-8s\t%-8s\n",
          "Key",
          "No",
          players[0],
          players[1],
          players[2],
          players[3]);

  for (int hashkey = 0; hashkey < 256; hashkey++)
  {
    dp = &TTroot[trick][hand][hashkey];
    if (dp->nextNo == 0)
      continue;

    for (int i = 0; i < dp->nextNo; i++)
    {
      if (i == 0)
        fprintf(fp, "0x%02x %2d ", hashkey, dp->nextNo);
      else
        fprintf(fp, "%4s %2s " , "", "");

      TransTable::KeyToDist(dp->list[i].key, handDist);
      TransTable::DistToLengths(trick, handDist, len);

      TransTable::LenToStr(len, line);
      fprintf(fp, "%s\n", line);
    }
  }
  fprintf(fp, "\n");
#endif
}


void TransTable::PrintAllSuits()
{
#ifndef SMALL_MEMORY_OPTION
  for (int trick = 11; trick >= 1; trick--)
  {
    for (int hand = 0; hand < DDS_HANDS; hand++)
    {
      fprintf(fp, "Trick %d, hand %s\n", trick, players[hand]);
      fprintf(fp, "====================\n\n");

      TransTable::PrintSuits(trick, hand);
    }
  }
#endif
}


void TransTable::MakeHistStats(
  int hist[],
  int * count,
  int * prod_sum,
  int * prod_sumsq,
  int * max_len,
  int last_index)
{
  *count = 0;
  *prod_sum = 0;
  *prod_sumsq = 0;
  *max_len = 0;

  for (int i = 1; i <= last_index; i++)
  {
    if (hist[i])
    {
      *prod_sum += i * hist[i];
      *prod_sumsq += i * i * hist[i];
      *count += hist[i];

      if (i > *max_len)
        *max_len = i;
    }
  }
}


int TransTable::CalcPercentile(
  int hist[],
  double threshold,
  int last_index)
{
  int cum = 0;

  for (int i = 1; i <= last_index; i++)
  {
    cum += hist[i];
    if (cum >= threshold)
      return i;
  }
  return -1;
}


void TransTable::PrintHist(
  int hist[],
  int num_wraps,
  int last_index)
{
  int count, prod_sum, prod_sumsq, max_len;

  TransTable::MakeHistStats(hist,
                            &count, &prod_sum, &prod_sumsq, &max_len, last_index);

  for (int i = 1; i <= last_index; i++)
    if (hist[i])
      fprintf(fp, "%7d\t%5d\n", i, hist[i]);

  fprintf(fp, "\n");
  fprintf(fp, "Entries\t%5d\n", count);
  if (count)
  {
    fprintf(fp, "Full\t%5d\n", num_wraps);

    double mean = prod_sum / static_cast<double>(count);
    fprintf(fp, "Average\t%5.2f\n", mean);

    double var = prod_sumsq /
                 static_cast<double>(count - mean * mean);
    if (var >= 0.)
      fprintf(fp, "Std.dev\t%5.2f\n", sqrt(var));

    fprintf(fp, "Maximum\t%5d\n", max_len);
  }
  fprintf(fp, "\n");
}


void TransTable::UpdateSuitHist(
  int trick,
  int hand,
  int hist[],
  int * num_wraps)
{
#ifdef SMALL_MEMORY_OPTION
  UNUSED(trick);
  UNUSED(hand);
  UNUSED(hist);
  UNUSED(num_wraps);
#else
  distHashType * dp;

  * num_wraps = 0;
  for (int i = 0; i <= DISTS_PER_ENTRY; i++)
    hist[i] = 0;

  for (int hashkey = 0; hashkey < 256; hashkey++)
  {
    dp = &TTroot[trick][hand][hashkey];
    hist [ dp->nextNo ]++;
    suitHist[ dp->nextNo ]++;

    if (dp->nextNo != dp->nextWriteNo)
    {
      (*num_wraps)++; // Not entirely correct
      suitWraps++;
    }
  }
#endif
}


void TransTable::PrintSuitStats(
  int trick,
  int hand)
{
#ifdef SMALL_MEMORY_OPTION
  UNUSED(trick);
  UNUSED(hand);
#else
  int hist[DISTS_PER_ENTRY + 1];
  int num_wraps;

  TransTable::UpdateSuitHist(trick, hand, hist, &num_wraps);

  fprintf(fp, "Suit histogram for trick %d, hand %s\n",
          trick, players[hand]);
  TransTable::PrintHist(hist, num_wraps, DISTS_PER_ENTRY);
#endif
}


void TransTable::PrintAllSuitStats()
{
#ifndef SMALL_MEMORY_OPTION
  suitWraps = 0;
  for (int i = 0; i <= DISTS_PER_ENTRY; i++)
    suitHist[i] = 0;

  for (int trick = 11; trick >= 1; trick--)
  {
    for (int hand = 0; hand < DDS_HANDS; hand++)
    {
      fprintf(fp, "Suit, Trick %d, hand %s\n", trick, players[hand]);
      fprintf(fp, "==========================\n\n");
      TransTable::PrintSuitStats(trick, hand);
    }
  }

  fprintf(fp, "Overall suit histogram\n");
  TransTable::PrintHist(suitHist, suitWraps, DISTS_PER_ENTRY);
#endif
}


void TransTable::PrintSummarySuitStats()
{
#ifndef SMALL_MEMORY_OPTION
  int hist[DISTS_PER_ENTRY + 1];
  int count, prod_sum, prod_sumsq,
                        max_len, num_wraps;

  suitWraps = 0;
  for (int i = 0; i <= DISTS_PER_ENTRY; i++)
    suitHist[i] = 0;

  fprintf(fp, "Suit depth statistics\n\n");

  fprintf(fp, "%5s %6s %7s %7s %7s %7s %7s P%-4.2f\n",
          "Trick",
          "Player",
          "Entries",
          "Full",
          "Average",
          "Std.dev",
          "Maximum",
          TT_PERCENTILE);

  for (int trick = 11; trick >= 1; trick--)
  {
    for (int hand = 0; hand < DDS_HANDS; hand++)
    {
      TransTable::UpdateSuitHist(trick, hand, hist, &num_wraps);
      TransTable::MakeHistStats(hist,
                                &count, &prod_sum, &prod_sumsq, &max_len, DISTS_PER_ENTRY);

      double mean = 0., var = 0.;
      if (count > 0)
      {
        mean = prod_sum / static_cast<double>(count);
        var = prod_sumsq /
               static_cast<double>(count - mean * mean);
        if (var < 0.)
          var = 0.;
      }

      int percentile =
        TransTable::CalcPercentile(hist,
                                   TT_PERCENTILE * count, DISTS_PER_ENTRY);

      if (count > 0)
        fprintf(fp, "%5d %-6s %7d %7d %7.2f %7.2f %7d %7d\n",
                trick,
                players[hand],
                count,
                num_wraps,
                mean,
                sqrt(var),
                max_len,
                percentile);
      else
        fprintf(fp, "%5d %-6s %7d %7d %7s %7s %7d %7d\n",
                trick,
                players[hand],
                count,
                num_wraps,
                "-",
                "-",
                max_len,
                percentile);
    }
    fprintf(fp, "\n");
  }
  fprintf(fp, "\n");
#endif
}


TransTable::winBlockType * TransTable::FindMatchingDist(
  int trick,
  int hand,
  int handDistSought[DDS_HANDS])
{
#ifdef SMALL_MEMORY_OPTION
  UNUSED(trick);
  UNUSED(hand);
  UNUSED(handDistSought);
  return NULL;
#else
  winBlockType * bp;
  distHashType * dp;
  int handDist[DDS_HANDS];

  for (int hashkey = 0; hashkey < 256; hashkey++)
  {
    dp = &TTroot[trick][hand][hashkey];
    for (int i = 0; i < dp->nextNo; i++)
    {
      bp = dp->list[i].posBlock;
      TransTable::KeyToDist(dp->list[i].key, handDist);

      bool same = true;
      for (int h = 0; h < DDS_HANDS; h++)
      {
        if (handDist[h] != handDistSought[h])
        {
          same = false;
          break;
        }
      }
      if (same)
        return bp;
    }
  }
  return nullptr;
#endif
}


void TransTable::PrintEntriesBlock(
  winBlockType * bp,
  unsigned char lengths[DDS_HANDS][DDS_SUITS])
{
  char line[40];
  char lines[2][80];

  TransTable::LenToStr(lengths, line);

  sprintf(lines[0],
          "%d matches for %s\n", bp->nextMatchNo, line);
  memset(lines[1], '=', 71);
  lines[1][71] = '\0';

  fprintf(fp, "%s%s\n\n", lines[0], lines[1]);

  for (int j = 0; j < bp->nextMatchNo; j++)
  {
    fprintf(fp, "Entry number %3d\n", j + 1);
    fprintf(fp, "----------------\n\n");
    TransTable::PrintMatch(&bp->list[j], lengths);
  }
}



void TransTable::PrintEntriesDistAndCards(
  int trick,
  int hand,
  unsigned short * aggrTarget,
  int handDist[DDS_HANDS])
{
#ifdef SMALL_MEMORY_OPTION
  UNUSED(trick);
  UNUSED(hand);
  UNUSED(aggrTarget);
  UNUSED(handDist);
#else
  char line[40];
  unsigned char len[DDS_HANDS][DDS_SUITS];

  winBlockType * bp =
    TransTable::FindMatchingDist(trick, hand, handDist);

  TransTable::DistToLengths(trick, handDist, len);

  fprintf(fp, "Looking up entry for trick %d, hand %d\n",
          trick, hand);
  TransTable::LenToStr(len, line);
  fprintf(fp, "%s\n\n", line);

  if (! bp)
  {
    fprintf(fp, "Entry not found\n\n");
    return;
  }

  unsigned * ab0 = aggr[ aggrTarget[0] ].aggrBytes[0];
  unsigned * ab1 = aggr[ aggrTarget[1] ].aggrBytes[1];
  unsigned * ab2 = aggr[ aggrTarget[2] ].aggrBytes[2];
  unsigned * ab3 = aggr[ aggrTarget[3] ].aggrBytes[3];

  winMatchType TTentry;
  TTentry.topSet1 = ab0[0] | ab1[0] | ab2[0] | ab3[0];
  TTentry.topSet2 = ab0[1] | ab1[1] | ab2[1] | ab3[1];
  TTentry.topSet3 = ab0[2] | ab1[2] | ab2[2] | ab3[2];
  TTentry.topSet4 = ab0[3] | ab1[3] | ab2[3] | ab3[3];

  int matchNo = 1;
  int n = bp->nextMatchNo - 1;
  winMatchType * wp = &bp->list[n];

  for (int i = n; i >= 0; i--, wp--)
  {
    if ((wp->topSet1 ^ TTentry.topSet1) & wp->topMask1)
      continue;

    if (wp->lastMaskNo != 1)
    {
      if ((wp->topSet2 ^ TTentry.topSet2) & wp->topMask2)
        continue;

      if (wp->lastMaskNo != 2)
      {
        if ((wp->topSet3 ^ TTentry.topSet3) & wp->topMask3)
          continue;
      }
    }

    fprintf(fp, "Match number %d\n", matchNo++);
    fprintf(fp, "---------------\n");
    TransTable::PrintMatch(&bp->list[i], len);
  }

  if (matchNo == 1)
    fprintf(fp, "%d matches for suit, none for cards\n\n", n);
  else
    fprintf(fp, "\n");
#endif
}


void TransTable::PrintEntriesDist(
  int trick,
  int hand,
  int handDist[DDS_HANDS])
{
#ifdef SMALL_MEMORY_OPTION
  UNUSED(trick);
  UNUSED(hand);
  UNUSED(handDist);
#else
  unsigned char len[DDS_HANDS][DDS_SUITS];

  winBlockType * bp =
    TransTable::FindMatchingDist(trick, hand, handDist);

  TransTable::DistToLengths(trick, handDist, len);

  if (! bp)
  {
    fprintf(fp, "Entry not found: Trick %d, hand %d\n",
            trick, hand);
    char line[80];
    TransTable::LenToStr(len, line);
    fprintf(fp, "%s\n\n", line);
    return;
  }

  TransTable::PrintEntriesBlock(bp, len);
#endif
}


void TransTable::PrintEntries(
  int trick,
  int hand)
{
#ifdef SMALL_MEMORY_OPTION
  UNUSED(trick);
  UNUSED(hand);
#else
  winBlockType * bp;
  distHashType * dp;
  int handDist[DDS_HANDS];
  unsigned char lengths[DDS_HANDS][DDS_SUITS];

  for (int hashkey = 0; hashkey < 256; hashkey++)
  {
    dp = &TTroot[trick][hand][hashkey];
    for (int i = 0; i < dp->nextNo; i++)
    {
      bp = dp->list[i].posBlock;
      TransTable::KeyToDist(dp->list[i].key, handDist);
      TransTable::DistToLengths(trick, handDist, lengths);

      TransTable::PrintEntriesBlock(bp, lengths);
    }
  }
#endif
}


void TransTable::PrintAllEntries()
{
#ifndef SMALL_MEMORY_OPTION
  for (int trick = 11; trick >= 1; trick--)
  {
    for (int hand = 0; hand < DDS_HANDS; hand++)
    {
      fprintf(fp, "Entries, trick %d, hand %s\n", trick, players[hand]);
      fprintf(fp, "==============================\n\n");
      TransTable::PrintEntries(trick, hand);
    }
  }
  fprintf(fp, "\n");
#endif
}


void TransTable::UpdateEntryHist(
  int trick,
  int hand,
  int hist[],
  int * num_wraps)
{
#ifdef SMALL_MEMORY_OPTION
  UNUSED(trick);
  UNUSED(hand);
  UNUSED(hist);
  UNUSED(num_wraps);
#else
  distHashType * dp;

  * num_wraps = 0;
  for (int i = 0; i <= BLOCKS_PER_ENTRY; i++)
    hist[i] = 0;

  for (int hashkey = 0; hashkey < 256; hashkey++)
  {
    dp = &TTroot[trick][hand][hashkey];
    for (int i = 0; i < dp->nextNo; i++)
    {
      int c = dp->list[i].posBlock->nextMatchNo;
      hist [c]++;
      suitHist[c]++;

      if (c != dp->list[i].posBlock->nextWriteNo)
      {
        (*num_wraps)++; // Not entirely correct
        suitWraps++;
      }
    }
  }
#endif
}


void TransTable::PrintEntryStats(
  int trick,
  int hand)
{
#ifdef SMALL_MEMORY_OPTION
  UNUSED(trick);
  UNUSED(hand);
#else
  int hist[BLOCKS_PER_ENTRY + 1];
  int num_wraps;

  TransTable::UpdateEntryHist(trick, hand, hist, &num_wraps);

  fprintf(fp, "Entry histogram for trick %d, hand %s\n",
          trick, players[hand]);
  TransTable::PrintHist(hist, num_wraps, BLOCKS_PER_ENTRY);
#endif
}


void TransTable::PrintAllEntryStats()
{
#ifndef SMALL_MEMORY_OPTION
  suitWraps = 0;
  for (int i = 0; i <= BLOCKS_PER_ENTRY; i++)
    suitHist[i] = 0;

  for (int trick = 11; trick >= 1; trick--)
  {
    for (int hand = 0; hand < DDS_HANDS; hand++)
    {
      fprintf(fp, "Entry, trick %d, hand %s\n", trick, players[hand]);
      fprintf(fp, "============================\n\n");
      TransTable::PrintEntryStats(trick, hand);
    }
  }

  fprintf(fp, "Overall entry histogram\n");
  TransTable::PrintHist(suitHist, suitWraps, BLOCKS_PER_ENTRY);
#endif
}


int TransTable::EffectOfBlockBound(
  int hist[],
  int size)
{
  // Calculates the number of blocks used if the blocks
  // are divided up in units of size, rather than in units
  // of BLOCKS_PER_ENTRY. Only makes sense if size is less
  // than BLOCKS_PER_ENTRY, as we won't have statistics for
  // how many blocks above BLOCKS_PER_ENTRY would be created
  // if BLOCKS_PER_ENTRY were larger.

  int cum_memory = 0;
  int unit_size = 0;

  for (int i = 1; i <= BLOCKS_PER_ENTRY; i++)
  {
    if ((i - 1) % size == 0)
      unit_size += size;

    cum_memory += hist[i] * unit_size;
  }
  return cum_memory;
}


// #define TT_MEMORY_SCENARIO

void TransTable::PrintSummaryEntryStats()
{
#ifndef SMALL_MEMORY_OPTION
  int hist[BLOCKS_PER_ENTRY + 1];
  int count, prod_sum, prod_sumsq,
                        max_len, num_wraps;

  int cumCount = 0;
  double cumProd = 0.;
#ifdef TT_MEMORY_SCENARIO
  int cumMemory = 0;
#endif

  suitWraps = 0;
  for (int i = 0; i <= BLOCKS_PER_ENTRY; i++)
    suitHist[i] = 0;

  fprintf(fp, "Entry depth statistics\n\n");

  fprintf(fp, "%5s %6s %7s %7s %7s %7s %7s P%-4.2f\n",
          "Trick",
          "Player",
          "Entries",
          "Full",
          "Average",
          "Std.dev",
          "Maximum",
          TT_PERCENTILE);

  for (int trick = 11; trick >= 1; trick--)
  {
    for (int hand = 0; hand < DDS_HANDS; hand++)
    {
      TransTable::UpdateEntryHist(trick, hand, hist, &num_wraps);
      TransTable::MakeHistStats(hist,
                                &count, &prod_sum, &prod_sumsq, &max_len, BLOCKS_PER_ENTRY);

      cumCount += count;
      cumProd += prod_sum;
#ifdef TT_MEMORY_SCENARIO
      cumMemory += TransTable::EffectOfBlockBound(hist, 20);
#endif

      double mean = prod_sum / static_cast<double>(count);
      double var = prod_sumsq /
                    static_cast<double>(count - mean * mean);
      if (var < 0.)
        var = 0.;

      int percentile =
        TransTable::CalcPercentile(hist,
                                   TT_PERCENTILE * count, BLOCKS_PER_ENTRY);

      fprintf(fp, "%5d %-6s %7d %7d %7.2f %7.2f %7d %7d\n",
              trick,
              players[hand],
              count,
              num_wraps,
              mean,
              sqrt(var),
              max_len,
              percentile);
    }
    fprintf(fp, "\n");
  }
  fprintf(fp, "\n");

  fprintf(fp, "Blocks counted\t%8d\n", cumCount);

  fprintf(fp, "Blocks produced\t%8d\n", TransTable::BlocksInUse());

#ifdef TT_MEMORY_SCENARIO
  fprintf(fp, "Mem scenario\t%7.2f%%\n",
          100. * cumMemory /
          (static_cast<double>(BLOCKS_PER_ENTRY * cumCount)));
#endif

  if (cumCount)
    fprintf(fp, "Fullness\t%7.2f%%\n",
            100. * cumProd / (BLOCKS_PER_ENTRY * cumCount));
  fprintf(fp, "\n");
#endif
}


void TransTable::PrintPageSummary()
{
#ifndef SMALL_MEMORY_OPTION
  if (pageStats.numResets == 0)
    return;

  fprintf(fp, "Page statistics\n\n");

  fprintf(fp, "%-10s %6s %6s\n",
          "Type", "Number", "Avg");

  fprintf(fp, "%-10s %6d\n",
          "Resets",
          pageStats.numResets);
  fprintf(fp, "%-10s %6d %6.2f\n",
          "calloc",
          pageStats.numCallocs,
          pageStats.numCallocs / static_cast<double>(pageStats.numResets));
  fprintf(fp, "%-10s %6d %6.2f\n",
          "free",
          pageStats.numFrees,
          pageStats.numFrees / static_cast<double>(pageStats.numResets));
  fprintf(fp, "%-10s %6d %6.2f\n\n",
          "harvest",
          pageStats.numHarvests,
          pageStats.numHarvests / static_cast<double>(pageStats.numResets));
#endif
}

void TransTable::PrintNodeStats()
{
#ifdef SMALL_MEMORY_OPTION
  for (int k = 13; k > 0; k--)
    fprintf(fp, "Trick %d: Created nodes: %ld\n", k, 
      static_cast<long>(aggrLenSets[k - 1]));
  fprintf(fp, "\n");
#endif
}

void TransTable::PrintResetStats()
{
#ifdef SMALL_MEMORY_OPTION
  fprintf(fp, "Total no of Resets: %d\n", statsResets.noOfResets);
  fprintf(fp, "\n");

  for (int k = 0; k <= 5; k++)
    fprintf(fp, "%s: %d\n", resetText[k], statsResets.aggrResets[k]);
  fprintf(fp, "\n");
#endif
}

